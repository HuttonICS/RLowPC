% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RLowPCor.R
\name{RLowPCor}
\alias{RLowPCor}
\title{Relevance low order partial correlation}
\usage{
RLowPCor(data.exp, edgelist, estimator = "pearson", pc.estimator = "shrink",
  progressbar = T)
}
\arguments{
\item{data.exp}{gene expression matrix. Columns are variables and rows are samples.}

\item{edgelist}{edge list. First column are the name of regulators, second coloumn are the target genes and the third column are the edge weights.}

\item{estimator}{a character string indicating which correlation coefficient (or covariance) is to be computed.Options are "pearson", "spearman"
and "kendall". If shrinkage method is used to estimate PC, the estimator is set to "pearson".}

\item{pc.estimator}{a character string indicating which method is used to estimate the PC of nodes connected to shared neigbours. Options are "shrink" and "pc",
correspoinding to the item (c) and (d) in Details: Step 2, respectively.}

\item{progressbar}{logical. If TRUE, a progressbar will show to indicate the code runing percentage.}
}
\value{
a network matrix
}
\description{
Relevance low order partial correlation (RLowPCor) is an improved version of partial correlation (PC)[1, 2].  Instead of removing all remained controls for pair-wise
PC calculation, RLowPCor selects and regresses the the most relevant controls. See Details.
}
\details{
Step 1:  Extract a sparse and scale-free topology from pre-inferred networks as an indirect edge search space for RLowPCor. Unlike a fully connected network,
the nodes in the sparse network are assumed to connect to their more relevant neighbours. For example, correlation network can be cut with a range of thresholds
until it most fit to scale-free topology.

Step 2: Calculate relevance low order partial correlation.  For each pair of nodes connected by an edge in the searching
space, the edge weight is redefined as (a) Pearson correlation if they do not connect to the same set of neighbour nodes, (b) PC by removing shared neighbours and
(c) shrink PC if the covariance matrix used to estimate PC in (b) is not positive definite or invertible. If the searching space is very large, there might still
be a number of irrelevant controls involved in shrink PC procedure (c). An alternative is (d) deleting less connected neighbours of the nodes until the covariance
matrix in (b) is positive definite and invertible.
}
\examples{
# Install RLowPCor and load R packages
##Install
library(devtools)
install_github('wyguo/RLowPCor')
###RLowPCor R package
library(RLowPCor)
##
library(minet)
library(Hmisc)
library(ppcor)
library(corpcor)
library(plyr)
library(ggplot2)
library(gridExtra)


#Load DREAm4 datasets and referecne network

data(gnwdata)
data.exp<-gnwdata$size100$ts1[,-c(1:2)]
genes<-colnames(data.exp)
##reference network edge list
ref.edge<-gnwdata$size100$net1
ref.edge[,3]<-1
ref.adj.raw<-edgelist2adjmatrix(ref.edge,genes)
##refernce network matrix
ref.adj<-ref.adj.raw[genes,genes]




#Infer correlation network

inf.cor<-abs(cor(data.exp))
diag(inf.cor)<-0


#Deterimine to top weighted search space.
The reduction of search space of correlation network is selected by testing the scale-free fitness of top weighted edges the number of which ranging from 100 to 2000. The testing results shows top edge number=180 indicates the optimal case.

fitness<-fit.structure(net=inf.cor,top.vector=seq(100,2000,by=20),method='scale-free')
top=as.numeric(names(fitness[fitness==max(fitness)]))
##choose the top 180 edges.
inf.cor.top<-top.network(inf.cor,top=top)


#Infer shrink PC network

inf.pcor<-abs(pcor.shrink(data.exp,verbose = F))[1:ncol(data.exp),1:ncol(data.exp)]
diag(inf.pcor)<-0
##choose the top 180 edges
inf.pcor.top<-top.network(inf.pcor,top=top)


#Infer firstPCor and secondPCor

## use the top weighted structure of correlation network as search space
adjmatrix<-inf.cor.top
## infer first order partial correlation network
inf.firstpcor<-abs(firstPCor(adjmatrix = adjmatrix,data.exp,progressbar = F)$cor)
##  infer second order partial correlation network
inf.secondpcor<-abs(secondPCor(adjmatrix = adjmatrix,data.exp,progressbar = F)$cor)


#Infer RLowPCor

##RLowPCor
inf.edge<-RLowPCor(data.exp,edgelist=adjmatrix2edgelist(inf.cor.top,directed=T),progressbar = F)
inf.rlowpcor<-edgelist2adjmatrix(inf.edge[,c(1,2,4)],genes=colnames(inf.cor.top),directed=F)


#Infer LowPCor

inf.lopcor<-LowPCor(data.exp,p.cut = 0.001,progressbar = F)$up2second$cor
inf.lopcor.top<-top.network(inf.lopcor,top=top)

#Generate confusion table

##convert the inferred metwork matrix to symmetric to match with reference network
inf.cor.top<-pmax(inf.cor.top,t(inf.cor.top))
inf.pcor.top<-pmax(inf.pcor.top,t(inf.pcor.top))
inf.firstpcor<-pmax(inf.firstpcor,t(inf.firstpcor))
inf.secondpcor<-pmax(inf.secondpcor,t(inf.secondpcor))
inf.lopcor.top<-pmax(inf.lopcor.top,t(inf.lopcor.top))
##generate confusion table
table.firstpcor<-table.evaluate(inf.firstpcor,ref.adj)
table.secondpcor<-table.evaluate(inf.secondpcor,ref.adj)
table.cor<-table.evaluate(inf.cor.top,ref.adj)
table.pcor<-table.evaluate(inf.pcor.top,ref.adj)
table.rlowpcor<-table.evaluate(inf.rlowpcor,ref.adj)
table.lowpcor<-table.evaluate(inf.lopcor.top,ref.adj)


#plot the partial auroc and aupr curves

cat(paste0('\\n Predictions of top ',top,' edges\\n'))
f=plotAUC(list(Cor=table.cor,
               firstPCor=table.firstpcor,
               secondPCor=table.secondpcor,
               shrink.PCor=table.pcor,
               RLowPCor=table.rlowpcor,
               LowPCor=table.lowpcor),lwd=1,fill=T,pr.lim = c(0,0.25,0,0.5),roc.lim = c(0,0.04,0,0.25),color = rainbow(6))


###Results and summary
The output pAUROC and pAUPR curvers are in Figure S4. It can be seen the performance of LowPCor inference method [@Zuo2014] is the worst. The pAUROC curve even does not distinguish from random guesses. Shrink PC method stays at the scond worst place. Different methods show different FPR and Recall cut-offs on top 180 edges in both pAUROC and pAUPR plots. As a results, a method may locally have good precision, but the areas under the curves are smaller than other methods, for example the RLowPCor method. The pAUPR plots indicate RLowPCor, firstPCor and secondPCor mehtods have higher precision at the smaller Recall cut-offs (see the curves close to 0 Recall).
{r,echo=F,message=F,warning=F, fig.width=6.69, fig.height=4,progress = F, verbose = F,dpi=300}
.libPaths('D:/R/win-library')
library(RLowPCor)
data(gnwdata)
data.exp<-gnwdata$size100$ts1[,-c(1:2)]
genes<-colnames(data.exp)
ref.edge<-gnwdata$size100$net1


ref.edge[,3]<-1
ref.adj.raw<-edgelist2adjmatrix(ref.edge,genes)
ref.adj<-ref.adj.raw[genes,genes]

##infer correlation network
inf.cor<-abs(cor(data.exp))
diag(inf.cor)<-0
##extract top network
fitness<-fit.structure(net=inf.cor,top.vector=seq(100,2000,by=20),method='scale-free')
top=as.numeric(names(fitness[fitness==max(fitness)]))
inf.cor.top<-top.network(inf.cor,top=top)

##  infer shrink partial correlation network
inf.pcor<-abs(pcor.shrink(data.exp,verbose = F))[1:ncol(data.exp),1:ncol(data.exp)]
diag(inf.pcor)<-0
inf.pcor.top<-top.network(inf.pcor,top=top)

adjmatrix<-inf.cor.top
## infer first order partial correlation network
inf.firstpcor<-abs(firstPCor(adjmatrix = adjmatrix,data.exp,progressbar = F)$cor)
##  infer second order partial correlation network
inf.secondpcor<-abs(secondPCor(adjmatrix = adjmatrix,data.exp,progressbar = F)$cor)

##RLowPCor
inf.edge<-RLowPCor(data.exp,edgelist=adjmatrix2edgelist(inf.cor.top,directed=T),progressbar = F)
inf.rlowpcor<-edgelist2adjmatrix(inf.edge[,c(1,2,4)],genes=colnames(inf.cor.top),directed=F)

inf.lopcor<-LowPCor(data.exp,p.cut = 0.001,progressbar = F)$up2second$cor
inf.lopcor.top<-top.network(inf.lopcor,top=top)

##convert the inferred metwork matrix to symmetric to match with reference network
inf.cor.top<-pmax(inf.cor.top,t(inf.cor.top))
inf.pcor.top<-pmax(inf.pcor.top,t(inf.pcor.top))
inf.firstpcor<-pmax(inf.firstpcor,t(inf.firstpcor))
inf.secondpcor<-pmax(inf.secondpcor,t(inf.secondpcor))
inf.lopcor.top<-pmax(inf.lopcor.top,t(inf.lopcor.top))
##generate confusion table
table.firstpcor<-table.evaluate(inf.firstpcor,ref.adj)
table.secondpcor<-table.evaluate(inf.secondpcor,ref.adj)
table.cor<-table.evaluate(inf.cor.top,ref.adj)
table.pcor<-table.evaluate(inf.pcor.top,ref.adj)
table.rlowpcor<-table.evaluate(inf.rlowpcor,ref.adj)
table.lowpcor<-table.evaluate(inf.lopcor.top,ref.adj)
##plot the auroc and aupr curves
cat(paste0('\\n Predictions of top ',top,' edges\\n'))
f=plotAUC(list(Cor=table.cor,
               firstPCor=table.firstpcor,
               secondPCor=table.secondpcor,
               shrink.PCor=table.pcor,
               RLowPCor=table.rlowpcor,
               LowPCor=table.lowpcor),lwd=1,fill=T,pr.lim = c(0,0.25,0,0.5),roc.lim = c(0,0.04,0,0.25),color = rainbow(6))

}
\references{
1. Markowetz F, Spang R: Inferring cellular networks-a review. BMC Bioinformatics 2007, 8 Suppl 6:S5.

2. Sch\"afer J, Strimmer K: A Shrinkage Approach to Large-Scale Covariance Matrix Estimation and Implications for Functional Genomics. Statistical Applications
in Genetics and Molecular Biology, The Berkeley Electronic Press 2005, 4(1).
}

